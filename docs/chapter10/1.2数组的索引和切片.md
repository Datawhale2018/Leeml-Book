
## 前言：
* Author： 修远
* Reviewer： 十三鸣
* 此系列数据分析笔记为Datawhale原创，将作为《李宏毅机器学习》的补充内容。
* 此系列笔记非常感谢齐伟老师，学习并且参考了他的书籍《跟老齐学Python:数据分析》

## 数组的索引与切片
* 用“序列”的观点来看数组，数组中每个元素都是固定的，可以用“索引”来表示数组中的每个元素


```python
import numpy as np
a = np.arange(24).reshape((2, 3, 4))
print(a )
print('\n')
print(a.shape)
print('\n')
print(a.ndim)
```

    [[[ 0  1  2  3]
      [ 4  5  6  7]
      [ 8  9 10 11]]
    
     [[12 13 14 15]
      [16 17 18 19]
      [20 21 22 23]]]
    
    
    (2, 3, 4)
    
    
    3
    

### 1、索引
* 可以看到上面我们创建了一个三维数组，规定：按照从外到内每一层是一个轴，从0开始计数，所以第一层就是0轴，第2层就是1轴，第三层就是2轴
* 轴上的元素也是从0开始计数，通过数组上的轴，我们可以操作任意指定方向上的元素
* 现在我们要打印元素12



```python
import numpy as np
a = np.arange(24).reshape((2, 3, 4))
print(a[1])
a[1][0][0]
```

    [[12 13 14 15]
     [16 17 18 19]
     [20 21 22 23]]
    

    12



###  2、根据索引取得数组的元素


```python
import numpy as np
b = np.linspace(0, 100, 5)   # 不同于python中常规的“前包括，后不包括”的原则
print(b)
```

    [  0.  25.  50.  75. 100.]
    


```python
b[1]
```




    25.0




```python
b[3]
```




    75.0




```python
c = np.logspace(1, 3, 12).reshape(3, 4)
c
# 可以看到0轴上有三个元素，1轴上有四个元素 （一个二维数组）
```




    array([[  10.        ,   15.19911083,   23.101297  ,   35.11191734],
           [  53.36699231,   81.11308308,  123.28467394,  187.38174229],
           [ 284.80358684,  432.87612811,  657.93322466, 1000.        ]])




```python
c.shape
```




    (3, 4)




```python
c[1]
```




    array([ 53.36699231,  81.11308308, 123.28467394, 187.38174229])




```python
c[1, 3]
```




    187.3817422860383




```python
c[1][3]
```




    187.3817422860383



####  数组跟列表相同，每个索引对应的值可以通过索引进行修改
* 对原来的数组没有任何影响，而是新生成了一个对象


```python
import numpy as np
d = np.linspace(0, 100, 5)
d[1] = 100
d
```




    array([  0., 100.,  50.,  75., 100.])




```python
c1 = np.logspace(1, 3, 12).reshape(3, 4)
c1
```




    array([[  10.        ,   15.19911083,   23.101297  ,   35.11191734],
           [  53.36699231,   81.11308308,  123.28467394,  187.38174229],
           [ 284.80358684,  432.87612811,  657.93322466, 1000.        ]])




```python
c1[1, 2] = 1
c1
```




    array([[  10.        ,   15.19911083,   23.101297  ,   35.11191734],
           [  53.36699231,   81.11308308,    1.        ,  187.38174229],
           [ 284.80358684,  432.87612811,  657.93322466, 1000.        ]])



####  下标为列表（一维数组）
* 可以看到上面用的是下标为整数，下面来看看下标为列表的形式


```python
b = np.linspace(1, 100, 5)
b
```




    array([  1.  ,  25.75,  50.5 ,  75.25, 100.  ])




```python
b[0], b[1], b[2]    # 从数组b中取出三个元素
# 如果用 b[0, 1, 2] 显然是会报错的(三维数组索引)
```




    (1.0, 25.75, 50.5)




```python
b[[0, 1, 2]]  # 返回一个数组，对应的是 b[0]，b[1]，b[2]的值
```




    array([ 1.  , 25.75, 50.5 ])




```python
b[[2]]
```




    array([50.5])



#### 可以看到列表作为下标时从原数组中改变了一些元素组成了新数组，这个新数组和原数组相互独立 (从内存来看没有公用一个内存)


```python
b = np.logspace(0, 100 ,5)
b1 = b[[0, 1, 2]]
b1
```




    array([1.e+00, 1.e+25, 1.e+50])




```python
b1[1] = 3
b1
```




    array([1.e+00, 3.e+00, 1.e+50])



####  下标为列表（二维数组）


```python
f = np.linspace(1, 100, 12).reshape(3, 4)
f
```




    array([[  1.,  10.,  19.,  28.],
           [ 37.,  46.,  55.,  64.],
           [ 73.,  82.,  91., 100.]])




```python
f[[0, 2]]
```




    array([[  1.,  10.,  19.,  28.],
           [ 73.,  82.,  91., 100.]])




```python
f[[0, 2], [1, 2]]
```




    array([10., 91.])



####  下标是数组
除了整数，列表，还可以是数组


```python
b = np.linspace(1, 100, 5)
b
```




    array([  1.  ,  25.75,  50.5 ,  75.25, 100.  ])




```python
b[np.array([2, 3, 2, 3])]
```




    array([50.5 , 75.25, 50.5 , 75.25])




```python
c = np.logspace(1 ,100, 12).reshape(3, 4)
c[np.array([1, 2])]
```




    array([[1.e+037, 1.e+046, 1.e+055, 1.e+064],
           [1.e+073, 1.e+082, 1.e+091, 1.e+100]])




```python
e = np.linspace(0, 100, 5)
t = b == 50
t
```




    array([False, False, False, False, False])




```python
A = []
for i in b:
    if i == 50 :
        A.append(True)
    else:
        A.append(False)
A
```




    [False, False, False, False, False]



### 3、 数组的切片：
* 下标和切片都可以从数组中得到部分元素，遵守“前包括， 后不包括”的原则


```python
import numpy as np
a = np.arange(10, 20)
a
```




    array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])




```python
b = a[2 : 8]
b
```




    array([12, 13, 14, 15, 16, 17])




```python
b[2] = 200
b
```




    array([ 12,  13, 200,  15,  16,  17])



#### 新得到的数组b中的第一个元素的值被修改了，同时数组a中的元素也得到了改变

* 通过切边得到的数组和原数组共享了一个内存空间

* 通过索引，得到的是两个不同的数组，占用不同的内存


```python
a = np.arange(10 ,20)
print(a[::2])
print(a[3:])
print(a[::-1])
```

    [10 12 14 16 18]
    [13 14 15 16 17 18 19]
    [19 18 17 16 15 14 13 12 11 10]
    

#### 对二维或者更多的数组进行切片，也是在一维是基础上进行操作的，分别在每个轴上实施，最终获得重叠区域


```python
b = np.arange(0, 60, 10).reshape(-1, 1) + np.arange(0, 6) #指定未知数量的行用-1代替，前一个语句是只指定产生一列的数据
b
```




    array([[ 0,  1,  2,  3,  4,  5],
           [10, 11, 12, 13, 14, 15],
           [20, 21, 22, 23, 24, 25],
           [30, 31, 32, 33, 34, 35],
           [40, 41, 42, 43, 44, 45],
           [50, 51, 52, 53, 54, 55]])




```python
b[1: 4]   # 在0轴方向上切片，得到了按照0轴方向上元素为单元的切片后的数组
```




    array([[10, 11, 12, 13, 14, 15],
           [20, 21, 22, 23, 24, 25],
           [30, 31, 32, 33, 34, 35]])




```python
print(b[1:4, 2:5])  # 先在0轴方向上“切出一片”，然后在1轴方向上安装[2:5]的要求“切出”
```

    [[12 13 14]
     [22 23 24]
     [32 33 34]]
    


```python
print(b[0])       # 在0轴方向上切片，得到了按照0轴方向上元素为单元的切片后的数组
print(b[1,:])     
```

    [0 1 2 3 4 5]
    [10 11 12 13 14 15]
    


```python
print(b[:, 2])
print('\n')
print(b[0:2, 0:2])
```

    [ 2 12 22 32 42 52]
    
    
    [[ 0  1]
     [10 11]]
    
